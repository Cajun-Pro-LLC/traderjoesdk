/*
Trader Joe Dex API

<p>Discover DeFi with Trader Joe, a leading decentralized exchange. Trade a wide variety of tokens, earn rewards, and engage in secure, peer-to-peer transactions. Trader Joe makes DeFi easy and accessible.

API version: 1.0.0
Contact: public-api@traderjoexyz.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package traderjoesdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type VaultsAPI interface {

	/*
		GetVault Get Vault

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain
		@param vaultAddress
		@return ApiGetVaultRequest
	*/
	GetVault(ctx context.Context, chain ChainParam, vaultAddress string) ApiGetVaultRequest

	// GetVaultExecute executes the request
	//  @return GetVault
	GetVaultExecute(r ApiGetVaultRequest) (*GetVault, *http.Response, error)

	/*
		GetVaultRecentActivity Get Vault Recent Activity

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain
		@param vaultAddress
		@return ApiGetVaultRecentActivityRequest
	*/
	GetVaultRecentActivity(ctx context.Context, chain ChainParam, vaultAddress string) ApiGetVaultRecentActivityRequest

	// GetVaultRecentActivityExecute executes the request
	//  @return []GetVaultActivity
	GetVaultRecentActivityExecute(r ApiGetVaultRecentActivityRequest) ([]GetVaultActivity, *http.Response, error)

	/*
		GetVaultSharePrice Get Vault Share Price

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain
		@param vaultAddress
		@return ApiGetVaultSharePriceRequest
	*/
	GetVaultSharePrice(ctx context.Context, chain Chain, vaultAddress string) ApiGetVaultSharePriceRequest

	// GetVaultSharePriceExecute executes the request
	//  @return []VaultSharePrice
	GetVaultSharePriceExecute(r ApiGetVaultSharePriceRequest) ([]VaultSharePrice, *http.Response, error)

	/*
		GetVaultTvlHistory Get Vault Tvl History

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain
		@param vaultAddress
		@return ApiGetVaultTvlHistoryRequest
	*/
	GetVaultTvlHistory(ctx context.Context, chain ChainParam, vaultAddress string) ApiGetVaultTvlHistoryRequest

	// GetVaultTvlHistoryExecute executes the request
	//  @return []GetVaultTVL
	GetVaultTvlHistoryExecute(r ApiGetVaultTvlHistoryRequest) ([]GetVaultTVL, *http.Response, error)

	/*
		GetVaultWithdrawalsByUser Get Vault Withdrawals By User

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain
		@param userAddress
		@return ApiGetVaultWithdrawalsByUserRequest
	*/
	GetVaultWithdrawalsByUser(ctx context.Context, chain ChainParam, userAddress string) ApiGetVaultWithdrawalsByUserRequest

	// GetVaultWithdrawalsByUserExecute executes the request
	//  @return []GetVaultWithdrawal
	GetVaultWithdrawalsByUserExecute(r ApiGetVaultWithdrawalsByUserRequest) ([]GetVaultWithdrawal, *http.Response, error)

	/*
		GetVaultWithdrawalsByUserAndVault Get Vault Withdrawals By User And Vault

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain
		@param vaultAddress
		@param userAddress
		@return ApiGetVaultWithdrawalsByUserAndVaultRequest
	*/
	GetVaultWithdrawalsByUserAndVault(ctx context.Context, chain ChainParam, vaultAddress string, userAddress string) ApiGetVaultWithdrawalsByUserAndVaultRequest

	// GetVaultWithdrawalsByUserAndVaultExecute executes the request
	//  @return []GetVaultWithdrawal
	GetVaultWithdrawalsByUserAndVaultExecute(r ApiGetVaultWithdrawalsByUserAndVaultRequest) ([]GetVaultWithdrawal, *http.Response, error)

	/*
		ListVaultsByChain List Vaults By Chain

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain
		@return ApiListVaultsByChainRequest
	*/
	ListVaultsByChain(ctx context.Context, chain ChainParam) ApiListVaultsByChainRequest

	// ListVaultsByChainExecute executes the request
	//  @return []GetVault
	ListVaultsByChainExecute(r ApiListVaultsByChainRequest) ([]GetVault, *http.Response, error)

	/*
		ListVaultsV1VaultsGet List Vaults

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListVaultsV1VaultsGetRequest
	*/
	ListVaultsV1VaultsGet(ctx context.Context) ApiListVaultsV1VaultsGetRequest

	// ListVaultsV1VaultsGetExecute executes the request
	//  @return []GetVault
	ListVaultsV1VaultsGetExecute(r ApiListVaultsV1VaultsGetRequest) ([]GetVault, *http.Response, error)
}

// VaultsAPIService VaultsAPI service
type VaultsAPIService service

type ApiGetVaultRequest struct {
	ctx          context.Context
	ApiService   VaultsAPI
	chain        ChainParam
	vaultAddress string
}

func (r ApiGetVaultRequest) Execute() (*GetVault, *http.Response, error) {
	return r.ApiService.GetVaultExecute(r)
}

/*
GetVault Get Vault

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain
	@param vaultAddress
	@return ApiGetVaultRequest
*/
func (a *VaultsAPIService) GetVault(ctx context.Context, chain ChainParam, vaultAddress string) ApiGetVaultRequest {
	return ApiGetVaultRequest{
		ApiService:   a,
		ctx:          ctx,
		chain:        chain,
		vaultAddress: vaultAddress,
	}
}

// Execute executes the request
//
//	@return GetVault
func (a *VaultsAPIService) GetVaultExecute(r ApiGetVaultRequest) (*GetVault, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetVault
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.GetVault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{chain}/{vault_address}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vault_address"+"}", url.PathEscape(parameterValueToString(r.vaultAddress, "vaultAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultRecentActivityRequest struct {
	ctx          context.Context
	ApiService   VaultsAPI
	chain        ChainParam
	vaultAddress string
	pageSize     *int32
	pageNum      *int32
}

func (r ApiGetVaultRecentActivityRequest) PageSize(pageSize int32) ApiGetVaultRecentActivityRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetVaultRecentActivityRequest) PageNum(pageNum int32) ApiGetVaultRecentActivityRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiGetVaultRecentActivityRequest) Execute() ([]GetVaultActivity, *http.Response, error) {
	return r.ApiService.GetVaultRecentActivityExecute(r)
}

/*
GetVaultRecentActivity Get Vault Recent Activity

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain
	@param vaultAddress
	@return ApiGetVaultRecentActivityRequest
*/
func (a *VaultsAPIService) GetVaultRecentActivity(ctx context.Context, chain ChainParam, vaultAddress string) ApiGetVaultRecentActivityRequest {
	return ApiGetVaultRecentActivityRequest{
		ApiService:   a,
		ctx:          ctx,
		chain:        chain,
		vaultAddress: vaultAddress,
	}
}

// Execute executes the request
//
//	@return []GetVaultActivity
func (a *VaultsAPIService) GetVaultRecentActivityExecute(r ApiGetVaultRecentActivityRequest) ([]GetVaultActivity, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetVaultActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.GetVaultRecentActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{chain}/{vault_address}/recent-activity"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vault_address"+"}", url.PathEscape(parameterValueToString(r.vaultAddress, "vaultAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "")
	} else {
		var defaultValue int32 = 1
		r.pageNum = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultSharePriceRequest struct {
	ctx           context.Context
	ApiService    VaultsAPI
	chain         Chain
	vaultAddress  string
	fromTimestamp *int32
	toTimestamp   *int32
}

func (r ApiGetVaultSharePriceRequest) FromTimestamp(fromTimestamp int32) ApiGetVaultSharePriceRequest {
	r.fromTimestamp = &fromTimestamp
	return r
}

func (r ApiGetVaultSharePriceRequest) ToTimestamp(toTimestamp int32) ApiGetVaultSharePriceRequest {
	r.toTimestamp = &toTimestamp
	return r
}

func (r ApiGetVaultSharePriceRequest) Execute() ([]VaultSharePrice, *http.Response, error) {
	return r.ApiService.GetVaultSharePriceExecute(r)
}

/*
GetVaultSharePrice Get Vault Share Price

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain
	@param vaultAddress
	@return ApiGetVaultSharePriceRequest
*/
func (a *VaultsAPIService) GetVaultSharePrice(ctx context.Context, chain Chain, vaultAddress string) ApiGetVaultSharePriceRequest {
	return ApiGetVaultSharePriceRequest{
		ApiService:   a,
		ctx:          ctx,
		chain:        chain,
		vaultAddress: vaultAddress,
	}
}

// Execute executes the request
//
//	@return []VaultSharePrice
func (a *VaultsAPIService) GetVaultSharePriceExecute(r ApiGetVaultSharePriceRequest) ([]VaultSharePrice, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []VaultSharePrice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.GetVaultSharePrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{chain}/{vault_address}/share-price"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vault_address"+"}", url.PathEscape(parameterValueToString(r.vaultAddress, "vaultAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromTimestamp == nil {
		return localVarReturnValue, nil, reportError("fromTimestamp is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromTimestamp", r.fromTimestamp, "")
	if r.toTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTimestamp", r.toTimestamp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultTvlHistoryRequest struct {
	ctx          context.Context
	ApiService   VaultsAPI
	chain        ChainParam
	vaultAddress string
	startTime    *int32
	endTime      *int32
}

func (r ApiGetVaultTvlHistoryRequest) StartTime(startTime int32) ApiGetVaultTvlHistoryRequest {
	r.startTime = &startTime
	return r
}

func (r ApiGetVaultTvlHistoryRequest) EndTime(endTime int32) ApiGetVaultTvlHistoryRequest {
	r.endTime = &endTime
	return r
}

func (r ApiGetVaultTvlHistoryRequest) Execute() ([]GetVaultTVL, *http.Response, error) {
	return r.ApiService.GetVaultTvlHistoryExecute(r)
}

/*
GetVaultTvlHistory Get Vault Tvl History

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain
	@param vaultAddress
	@return ApiGetVaultTvlHistoryRequest
*/
func (a *VaultsAPIService) GetVaultTvlHistory(ctx context.Context, chain ChainParam, vaultAddress string) ApiGetVaultTvlHistoryRequest {
	return ApiGetVaultTvlHistoryRequest{
		ApiService:   a,
		ctx:          ctx,
		chain:        chain,
		vaultAddress: vaultAddress,
	}
}

// Execute executes the request
//
//	@return []GetVaultTVL
func (a *VaultsAPIService) GetVaultTvlHistoryExecute(r ApiGetVaultTvlHistoryRequest) ([]GetVaultTVL, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetVaultTVL
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.GetVaultTvlHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{chain}/{vault_address}/tvl-history"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vault_address"+"}", url.PathEscape(parameterValueToString(r.vaultAddress, "vaultAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTime", r.endTime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultWithdrawalsByUserRequest struct {
	ctx         context.Context
	ApiService  VaultsAPI
	chain       ChainParam
	userAddress string
	pageSize    *int32
	pageNum     *int32
}

func (r ApiGetVaultWithdrawalsByUserRequest) PageSize(pageSize int32) ApiGetVaultWithdrawalsByUserRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetVaultWithdrawalsByUserRequest) PageNum(pageNum int32) ApiGetVaultWithdrawalsByUserRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiGetVaultWithdrawalsByUserRequest) Execute() ([]GetVaultWithdrawal, *http.Response, error) {
	return r.ApiService.GetVaultWithdrawalsByUserExecute(r)
}

/*
GetVaultWithdrawalsByUser Get Vault Withdrawals By User

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain
	@param userAddress
	@return ApiGetVaultWithdrawalsByUserRequest
*/
func (a *VaultsAPIService) GetVaultWithdrawalsByUser(ctx context.Context, chain ChainParam, userAddress string) ApiGetVaultWithdrawalsByUserRequest {
	return ApiGetVaultWithdrawalsByUserRequest{
		ApiService:  a,
		ctx:         ctx,
		chain:       chain,
		userAddress: userAddress,
	}
}

// Execute executes the request
//
//	@return []GetVaultWithdrawal
func (a *VaultsAPIService) GetVaultWithdrawalsByUserExecute(r ApiGetVaultWithdrawalsByUserRequest) ([]GetVaultWithdrawal, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetVaultWithdrawal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.GetVaultWithdrawalsByUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{chain}/withdrawals/{user_address}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_address"+"}", url.PathEscape(parameterValueToString(r.userAddress, "userAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "")
	} else {
		var defaultValue int32 = 1
		r.pageNum = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultWithdrawalsByUserAndVaultRequest struct {
	ctx          context.Context
	ApiService   VaultsAPI
	chain        ChainParam
	vaultAddress string
	userAddress  string
	pageSize     *int32
	pageNum      *int32
}

func (r ApiGetVaultWithdrawalsByUserAndVaultRequest) PageSize(pageSize int32) ApiGetVaultWithdrawalsByUserAndVaultRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetVaultWithdrawalsByUserAndVaultRequest) PageNum(pageNum int32) ApiGetVaultWithdrawalsByUserAndVaultRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiGetVaultWithdrawalsByUserAndVaultRequest) Execute() ([]GetVaultWithdrawal, *http.Response, error) {
	return r.ApiService.GetVaultWithdrawalsByUserAndVaultExecute(r)
}

/*
GetVaultWithdrawalsByUserAndVault Get Vault Withdrawals By User And Vault

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain
	@param vaultAddress
	@param userAddress
	@return ApiGetVaultWithdrawalsByUserAndVaultRequest
*/
func (a *VaultsAPIService) GetVaultWithdrawalsByUserAndVault(ctx context.Context, chain ChainParam, vaultAddress string, userAddress string) ApiGetVaultWithdrawalsByUserAndVaultRequest {
	return ApiGetVaultWithdrawalsByUserAndVaultRequest{
		ApiService:   a,
		ctx:          ctx,
		chain:        chain,
		vaultAddress: vaultAddress,
		userAddress:  userAddress,
	}
}

// Execute executes the request
//
//	@return []GetVaultWithdrawal
func (a *VaultsAPIService) GetVaultWithdrawalsByUserAndVaultExecute(r ApiGetVaultWithdrawalsByUserAndVaultRequest) ([]GetVaultWithdrawal, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetVaultWithdrawal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.GetVaultWithdrawalsByUserAndVault")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{chain}/{vault_address}/withdrawals/{user_address}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vault_address"+"}", url.PathEscape(parameterValueToString(r.vaultAddress, "vaultAddress")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_address"+"}", url.PathEscape(parameterValueToString(r.userAddress, "userAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "")
	} else {
		var defaultValue int32 = 1
		r.pageNum = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVaultsByChainRequest struct {
	ctx         context.Context
	ApiService  VaultsAPI
	chain       ChainParam
	pageSize    *int32
	pageNum     *int32
	userAddress *string
}

func (r ApiListVaultsByChainRequest) PageSize(pageSize int32) ApiListVaultsByChainRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListVaultsByChainRequest) PageNum(pageNum int32) ApiListVaultsByChainRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiListVaultsByChainRequest) UserAddress(userAddress string) ApiListVaultsByChainRequest {
	r.userAddress = &userAddress
	return r
}

func (r ApiListVaultsByChainRequest) Execute() ([]GetVault, *http.Response, error) {
	return r.ApiService.ListVaultsByChainExecute(r)
}

/*
ListVaultsByChain List Vaults By Chain

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain
	@return ApiListVaultsByChainRequest
*/
func (a *VaultsAPIService) ListVaultsByChain(ctx context.Context, chain ChainParam) ApiListVaultsByChainRequest {
	return ApiListVaultsByChainRequest{
		ApiService: a,
		ctx:        ctx,
		chain:      chain,
	}
}

// Execute executes the request
//
//	@return []GetVault
func (a *VaultsAPIService) ListVaultsByChainExecute(r ApiListVaultsByChainRequest) ([]GetVault, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetVault
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.ListVaultsByChain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults/{chain}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "")
	} else {
		var defaultValue int32 = 1
		r.pageNum = &defaultValue
	}
	if r.userAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userAddress", r.userAddress, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVaultsV1VaultsGetRequest struct {
	ctx        context.Context
	ApiService VaultsAPI
	pageSize   *int32
	pageNum    *int32
}

func (r ApiListVaultsV1VaultsGetRequest) PageSize(pageSize int32) ApiListVaultsV1VaultsGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListVaultsV1VaultsGetRequest) PageNum(pageNum int32) ApiListVaultsV1VaultsGetRequest {
	r.pageNum = &pageNum
	return r
}

func (r ApiListVaultsV1VaultsGetRequest) Execute() ([]GetVault, *http.Response, error) {
	return r.ApiService.ListVaultsV1VaultsGetExecute(r)
}

/*
ListVaultsV1VaultsGet List Vaults

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListVaultsV1VaultsGetRequest
*/
func (a *VaultsAPIService) ListVaultsV1VaultsGet(ctx context.Context) ApiListVaultsV1VaultsGetRequest {
	return ApiListVaultsV1VaultsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []GetVault
func (a *VaultsAPIService) ListVaultsV1VaultsGetExecute(r ApiListVaultsV1VaultsGetRequest) ([]GetVault, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetVault
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VaultsAPIService.ListVaultsV1VaultsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	} else {
		var defaultValue int32 = 20
		r.pageSize = &defaultValue
	}
	if r.pageNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNum", r.pageNum, "")
	} else {
		var defaultValue int32 = 1
		r.pageNum = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-traderjoe-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
